# Работа с коллекциями

## `1. Массивы`

Обычно массивы понимаются как последовательные ячейки памяти с однотипными элементами...

В JavaScript все немного иначе. Массивы - это объекты.

Преимущества состоят в удобстве обработки.

Недостатки в производительности.

## `1.1 Массивы - Создание массивов`

Есть два основных способа создания массивов:

- через специальный конструктор `Array`

- через литерал массивов `[]`

Литерал предпочтительней из-за краткости и надежности.

А встроенный конструктор `new Array()` может кто-то и переписать зачем-то

```
const animals = ['dog', 'cat', 'parrot'];
const animals2 = new Array('dog', 'cat', 'parrot');
```

Обращение за пределами длины массива даст `undefined`

```
animals[5]; // undefined
```

Обычно выдается ошибка "индекс за пределами границ массива..." . Но в JS мы работаем с объектами,

и у нас результат `undefined` так как нет доступа к несуществующему свойству объекта.

Запись за пределами массива расширяет его

```
animals[4] = 'mouse'; // ['dog', 'cat', 'parrot', 'mouse']
```

Если запишем не по порядку, то в массиве еще и дыра образуется:

|        |        |             |        |
| ------ | ------ | ----------- | ------ |
| elem 1 | elem 2 | `undefined` | elem 3 |

То есть установка большой длины произвольно даст расширение массива неопределенными

элементами - `undefined`.

Переопределение свойства length в меньшую сторону - сокращает массив

```
animals.length = 2;
```

## `1.2 Массивы - Добавление / удаление элементов`

Методы `push() и pop()` работают только с последним элементом массива.

Поэтому они быстрые и им предпочтение.

Методы `unshift() shift()` работают только с первым элементом и

влияют на всю последующую индексацию.

Самый простой способ удалить элемент, это использовать `delete`

```
delete animals[2];

```

Но длина массива останется той же, вместо элемента будет `undefined`

|     |     |           |        |
| --- | --- | --------- | ------ |
| dog | cat | undefined | rabbit |

Для корректного удаления используем метод `splice(1,1)`

Он принимает точку начала (индекс элемента) и сколько удалить элементов.

В результату возвращается новый массив с вырезанными элементами.

> Метод `splice()` изменяет изначальный массив !!!

Также можно вставлять элементы куда хотим:

```
animals.splice(1, 1, 'pig', 'pony');

```

То есть под индексом 1 элемент удалится и будет туда вставлено 2 новых.

## `1.3 Массивы - Основные операции над массивами`

Метод перебора циклом `for` объемен и часто предполагает мелкие ошибки.

Его сменили на `forEach`:

```
const animals = [
  { type: 'dog', age: 3 },
  { type: 'cat', age: 1 },
  { type: 'parrot', age: 5 },
];

animals.forEach((animal) => demo.push(animal.age));
```

Это тот же перебор массива на месте.

- `Отображение массива через map()`

Создание нового массива из элементов существующего называется `отображением массива`.

Это настолько частая операция, что вместо `forEach()` был веден метод `map().

```
const ages = animals.map( animal => animal.age);
```

- `Проверка массивов через every() и some()`

Оба метода возвращают `true / false`

```
const animals = [
  { type: 'dog', age: 3 },
  { type: 'cat', age: 1 },
  { type: 'parrot', },
];

const isAllHasAge = animals.every( animal => 'age' in animal);

const isAnyHasAge = animals.some( animal => 'age' in animal);
```

`every()` даст `true` только если все объекты в массиве имеют свойство 'age'

`some()` даст `true` если хотябы один объект в массиве имеет свойство 'age'

- `Поиск только одного элемента по условию find()`

Метод `find()` вернет первый из найденных элементов, соответствующий условию

либо вернет `undefined`

```
const result = animals.find( animal => animal.type === 'dog')
```

- `Поиск нескольких элементово условию filter()`

Метод вернет новый массив.

```
const result = animals.filter( animal => 'age' in animal);

```

- `Поиск индексов элементов indexOf() lastIndexOf() findIndex()`

В простом массиве без объектов удобно использовать `indexOf()`

Вернет индекс первого из соответствий или -1

```
animal.indexOf('cat');

```

`lastindexOf()` вернет последнее из соответствий или -1

```
animal.indexOf('cat');

```

В сложном поиске массива из объектов удобен метод `findIndexOf()`

Он вернет индекс первого же соответствия

```
const index = animals.findIndexOf( animal => animal.type === 'dog');

```

- `Сортировка массива sort()`

Этот вариант сортировки корректен в общих моментах.

|        |     |                           |
| ------ | --- | ------------------------- |
| a < b  | -1  | a должен предшествовать b |
| a > b  | 1   | a должен быть после b     |
| a == b | 0   | оставить все как есть     |

```
animals.sort((a, b) => {
  if (a.type < b.type) return -1;
  if (a.type > b.type) return 1;
  return 0;
});

```

- `Агрегирование элементов массива reduce()`

Для каждого элемента массива вызывается колбек, в который передается текущее

значение аккумулятора, накопленное в результате всех предыдущих вызовов и значение

текущего элемента.
