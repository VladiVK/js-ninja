## Functions

### `1.1- Функции - Сохранение уникальных функций в коллекции`

---

Будут вводиться в кэш только уникальные функции. Проверка по наличию ID.

Функция - объект высшего порядка и ничто не мешает добавить свойство

в функцию: `fn.id = 2;`

```
const store = {
    nextID: 1,
    cache: {},
    add: function (fn) {
        if (!fn.id) {
        fn.id = this.nextID++;
        this.cache[fn.id] = fn;
        return true;
        }
    },
};

function fnOne() {}
function fnTwo() {}
function fnThree() {}

store.add(fnOne);
store.add(fnTwo);
store.add(fnThree);

```

### `1.2- Функции - Запоминание (memoization) ранее вычисленных значений`

---

Запоминание `(memoization)` представляет собой построение функции, способной запомнить

ранее вычисленные значения. Позволяет избегнуть дорогостоящих повторных вычислений.

`Алгоритм вычисления простых чисел (больше 1 и делется без остатка только на 1 и само себя)`

```
function isPrime(value) {
  // create cache

  if (!isPrime.answers) {
    isPrime.answers = {};
  }

  // check if we have cached notes

  if (isPrime.answers[value] !== undefined) {
    return isPrime.answers[value];
  }

  // calculation

  let prime = (value !== 0 && value !== 1);

  for (let i = 2; i < value; i++) {
    if (value % i === 0) {
      prime = false;
      break;
    }
  }

  // save computed value
  isPrime.answers[value] = prime;

  //   return result
  return isPrime.answers[value];
}

isPrime(3);
isPrime(4);
isPrime(5);

console.log(isPrime.answers);


```

### `1.3 - Функции -Определение функций`

---

1. Объявление функции и функционального выражения

`function fn(){ return 'hello' }`

2. Стрелочные (часто наз. лямбда-функции)

`(arg) => return arg;`

3. Конструкторы функций ( не путать с функциями-конструкторами !!! )

`new Function('a', 'b', 'return a + b')`

4. Функции-генераторы

`function* myGen() {yield 1}`

Если мы объявляем функцию через `function`, то имя обязательно:

к ней ведь надо как-то обращаться потом!!!

Но, если через функциональное выражение, то не обязательно:

`const fn = function() {}`

### `1.4 - Функции - IIFE - Немедленно вызываемые функциональные выражения`

---

Это позволяет изолировать код ( эпоха до модулей )

```
(function (arg) {
  console.log('arg: ', arg);
}(3));

(function (arg) {
  console.log('arg: ', arg);
})(3);

(funtion(){}())

(funtion(){})()

+function(){}();

-function(){}();

~function(){}();

!(function () {})();


let person1 = (() => 'Bob')(); // 'Bob'

let person2 = (() => {'Bob'})(); // undefined

```

### `1.5 - Функции - Параметры и аргументы`

---

Если в функции предполагается параметров больше, чем по факту передали аргументов при вызове,

то им присваивается `undefined`;

Если аргументов, больше, чем параметров, то лишние аргументы просто никому не присваиваются!

`Оперетор ...rest`

Речь идет именно об "оставшемся параметре" - последнем!!!

Наличие его в середине параметров недопустимо!

Используем при определениии / объявлении функциии !

Спред же используем если надо при вызове с аргументами уже ...!!!

`...rest` выступит в качестве массива оставшихся аргументов!!!

Задача: умножить первый аргумент на наибольший из оставшихся:

```
function multiplyMax(first, ...rest) {
  const sorted = rest.sort((a, b) => b - a);
  return first * sorted[0];
}

multiplyMax(3, 1, 2, 3);
// 3 * 3 = 9;

вызов со спредом:

multiplyMax(3, 1, 2, 3, ...[1, 2, 5]);

// 3 * 5 = 15


```

`Параметры по умолчанию`

Старый подход:

```

function fn(par1, par2) {
  par2 = typeof par2 === 'undefined' ? 'Bob' : par2;
  return `${par1} ${par2}`;
}

```

Новый подход:

```

function fn(par1, par2 = 'Bob') {
  return `${par1} ${par2}`;
}

```

Можно даже так (но это bad practice):

```

function fn(par1, par2 = 'Bob', par3 = `${par1} ${par2}`) {
  return par3;
}

```

### `1.6 - Функции - Параметры this и arguments`

---

Это неявные параметры, они дефолтно передаются функциям.

`this` - контекст функции, объект для которого она вызывается.

`arguments` - все аргументы, передаваемые при вызове функции.

## `arguments`

передаются неявно, но по умолчанию и находятся в области видимости функции

Это коллекция всех аргументов. После ES6 оператора `...rest` потребность

в `arguments` существенно сократилась.

Коллекция `arguments` похоже на массив! Но это НЕ МАССИВ!

Есть свойство `arguments`, можно обращаться к элементам по индексу, но это не массив.

Методы массива работать не будут!

```
function sum() {
  let sum = 0;

  for (let i = 0; i < arguments.length; i++) {
    sum += arguments[i];
  }

  return sum;
}


sum(1,2,3); // 6

```

Но проще использовать `...rest` так как это уже подлинный массив!

```
function sum(...rest) {
  return rest.reduce((acc, val) => acc + val, 0);
}

sum(1,2,3); // 6
```

Коллекция `arguments` позволяет задавать псевдонимы параметрам, но это изменит и

значение аргументов:

```
function demo(person) {
  arguments[0] = 'ninja';

  return `the person is ${person}`;
}

demo('Rembo'); // 'ninja' не 'Rembo'

```

Это все считается как баг...

Поэтому используетс `'use strict'`, который не позволяет менять значение аргументов.

То есть параметру можно задать псевдоним, но аргумен не изменится.

## `this`

Это неявный параметр. Означает объект, связанный с вызовом функции - то есть контекст функции!!!

Ошибочно считать, что `this` указывает на экземпляр объекта, в котором определен метод.

`this` определяется не тем, как функции объявляется, а тем, как она вызвана!!!!

### `1.7 - Функции - Вызов функции`

---

В `JS` способ вызова функции влияет на порядок выполнения кода и

установку параметра `this`

Есть 4 способа вызова функции со своими особенностями.

1. как функция `demo()`

2. как метод `ninja.demo()`

3. как конструктор `new Ninja()`

4. через методы `apply` и `call` отдельной функции `demo.call(ninja)`

- ## Вызов как функции

Это вызов с помощью опреатора скобок `()`, и выражение на которое операция вызова ссылается

не является методом объекта!

```
demo();

const demo = function(){};
demo();

(function(){})()

```

При таком вызове устанавливается контекст `this` двояко:

при обычном режиме - это `window`

при строгом - это `undefined`

```
function demo() {
  this.id = '1nvfuvh75';
  return this.id;
}

demo(); // '1nvfuvh75';


window.id; // '1nvfuvh75';
```

Все зависит от очереди вызова функции еще:

```
function demo() {
  this.id = '01-demo';
  return this.id;
}
function test() {
  this.id = '01-test';
  return this.id;
}

До вызова функций window.id; // undefined

demo();
window.id; // 01-demo;

test();
window.id; // 01-dtest;
```

Вызов функции переписал глобальный контекст в нашем случае.

- ## Вызов как метод

```
const ninja = {};
ninja.skulk = function () {
  return this;
};
ninja.skulk();

```

Это означает, что при таком вызове функции ее контекстом становится объект!!!

И через `this` нам этот контекст / объект доступен.

```
ninja.skulk() === ninja; // true
```

Ниже видно, что контекст будет менятся в зависимости от того, как вызвана функция `outer()`:

```
function myContext() {
  return this;
}

myContext(); // window

const ninja = {
  getInfo: myContext;
}

ninja.getInfo(); // ninja;

ninja.getInfo() === ninja; // true

```

Поэтому не обязательно создавать новые одинаковые функции для разных объектов.

- ## Вызов через конструктор

Вызов через конструктор предполагает использования

ключевого слова `new`.

Конструкторы функций не стоит путать с функциями-конструкторами, которые нужны для инициализации

и создания экземпляров объектов !!!

```
function Ninja() {
  this.skulk = function () {
    return this;
  };
}

const ninja1 = new Ninja();
const ninja2 = new Ninja();

ninja1.skulk() === ninja1; // true
ninja2.skulk() === ninja2; // true

```

1. Есть конструктор, который создает экземпляр пустого объекта,

2. и этот пустой объект будет контекстом функции через `this`

3. метод `skulk` вернет `this` вновь созданного объекта

У функций конструкторов есть особенности !!!!

### Изменим код и вернем из конструктора простое строчное значение.

```
function Ninja() {
  this.skulk = function () {
    return this;
  };
  return 'I am Ninja constructor!';
}

Ninja(); // I am Ninja constructor!

```

При этом все остальное также работает:

```
const ninja1 = new Ninja();
const ninja2 = new Ninja();

ninja1.skulk() === ninja1; // true
ninja2.skulk() === ninja2; // true

```

Но перепишем код:

```
const sumuray = {
  name: false,
};

function Ninja() {
  this.skulk = true;
  return sumuray;
}

const ninja1 = new Ninja();
const ninja2 = new Ninja();

ninja1.skulk; // undfined
ninja2.skulk; // undfined

ninja1.name; // false
ninja2.name; // false



```

Итак, усли конструктор возвращает простое значение (НЕ ОБЪЕКТ), то

все работает и контекст `this` создается.

НО если возвращается ОБЪЕКТ, то результатом всей операции через `new`

будет просто возврат этого самого объекта. А вновь созданный объект с параметром

`this` просто игнорируется.

То есть `ninja1` станет просто второй ссылкой на внешний объект `sumuray`

```
ninja1 === sumuray; // true
```

Функции-конструкторы обычно кодируются иначе, чем обычные функции. В другом случае от них

мало пользы.

Пример проблемы: вызовем конструктор как простую функцию без `new`

```
function Ninja() {
  this.skulk = function () {
    return this;
  };
}

const ninja1 = Ninja();

```

Мы просто создали метод `skulk` для глобального объекта `window`,

а в `ninja1` у нас будет `undefined`.

Поэтому для именования консрукторов берутся обычно существительные `Car()` `Ninja()`

и пишутся с большой буквы.

Обычные функции именуются глаголами.

- ## Вызов через `apply` методы и `call`

Итак, в зависимости от того, как вызвана функция, будет установлен ее контекстный объект с

указателем `this` на этот контект.

- вызовем просто как функцию верхнего уровня и получим контекст `window`

- вызовем как метод объекта и получим контекст в виде объекта-владельца метода

- вызовем через конструктор и получим контекст в виде экземпляра нового объекта

Представим ситуацию-проблему:

```
function Button() {
  this.clicked = false;
  this.click = function () {
    this.clicked = true;
    console.log(this);
  };
}
const button = new Button();

const elem = document.querySelector('.btn');

elem.addEventListener('click', button.click);


```

Мы нажимаем на кнопку и метод объекта `button` сработает, но

не для него, а для `elem` - то есть кнопки;

```
console.log(this); // <button class='btn>
то есть elem наш !!!

elem.clicked; // true стал
```

Контекстом для `this` выступил объект, к которомы привязан обработчик событий.

- ## Применение `apply` и `call`

В JS можно можно вызвать функцию и ЯВНО УКАЗАТЬ ОБЪЕКТ для КОНТЕКСТА этой функции.

У каждой функции (как объекта) есть методы `apply()` и `call()`

`apply` - вызываем и передаем два параметра: объект для контекста и `массив` аргументов

`call` - - вызываем и передаем два параметра: объект для контекста и `список` аргументов

Решим проблему предыдущую (здесь метод и аргументы вторичны):

```
elem.addEventListener('click', function () {
  button.click.apply(button);
});
```

или

```
elem.addEventListener('click', function () {
  button.click.call(button);
});

```

Привидем иной пример. Используем всю функцию для вычисления, а не просто метод.

```
function juggle() {
  let result = 0;

  for (let i = 0; i < arguments.length; i++) {
    result += arguments[i];
  }

  this.sum = result;
}

const ninja1 = {};
const ninja2 = {};

juggle.apply(ninja1, [2, 3, 4, 5]);
juggle.apply(ninja2, 1,2,3,4);

```

- ## Контекст и стрелочные функции `() => {}`

У стрелочных функций отсутствует собственный контекст !!!

Вместо этого они наследуют контекст той функции, в которой определяются.

То есть во время вызова они не получают свой неявный параметр `this`.

Но они помнят контекст для `this` в момент своего создания.

Перепишем пример с кнопкой:

```
function Button() {
  this.clicked = false;
  this.click = () => {    // замена на стрелочную
    this.clicked = true;
    console.log(this);
  };
}

```

далее

```
const button = new Button(); // момент создания !!! Контекст будут запомнен

```

далее

```
const elem = document.querySelector('.btn');

elem.addEventListener('click', button.click);

```

теперь

```
button.clicked; // true
```

- ## Ловушка глобального `window` и стрелочные функции `() => {}`

Немного перепишем код:

```
const button = {
  clicked: false,
  click: () => {
    this.clicked = true;
    console.log(this);
  },
};

const elem = document.querySelector('.btn');

elem.addEventListener('click', button.click);

// this выступит для глобального объекта `window` !!!

window.clicked; // true
button.clicked; // false
```

В глобальном коде стрелочная фнкция ссылается на глобальный объект `window`.

Правило: если стрелочная функция определяется в обычно литеральном объекте,

который, в свою очередь написан просто на верхнем уровне, в глобальном коде,

то значением `this` для стрелочной функции станет `window`

- ## Вызов через метод `bind()`

Каждой функции доступен метод `bind()`.

Он служит для создания новой функции. Эта функции имеет то же самое тело, но

ее контекст всегда привязан к определенному объекту, независимо от

способа вызова !!!

Для начала избавимся от стрелочной функции в литерале объекта

```
const button = {
  clicked: false,
  click: function () {    // нет стрелки больше
    this.clicked = true;
    console.log(this);
  },
};
```

```
const elem = document.querySelector('.btn');

elem.addEventListener('click', button.click.bind(button));
```

Метод `call()` требовал обертку, что сразу вызов не сработал

```
elem.addEventListener('click', function () {
  button.click.call(button);
});
```

Метод `bind()` используется для создания и возврата новой функции, привязанной

к передаваемому в этой функции объекту: `button.click.bind(button)`

`this` всегда укажет на контекст этого объекта.

Метод `bind()` не изменяет исходную функции - всегда создается и возвращается новая

### `1.8 - Функции - Замыкания`

---

Замыкания - определяющее языковое средство `JavaScript`.

Введения замыканий и способа написания кода с ними определили перспективы языку.

- ## `Общее представление о замыканиях`

`Замыкание` предоставляет функции доступ к внешним по отношению к ней переменным и

возможность ими манипулировать. В момент определения функции формируется ее область видимости

и замыкание дает доступ ко всем переменным и функциям в этой области видимости.

`Область видимости` - доступность идентификаторов (видимость их) в определеннях

частях программы.

Простой пример замыкания: переменая и функции объявлены в одной (глобальной)

области видимости

```
let value = 'ninja;
function getNinja() {}
```

Еще пример:

Переменная `later` получила доступ к `innerValue` через замыкание.

```
let outerValue = 'ninja';
let later;

function outerFunction() {
  let innerValue = 'samurai';
  function innerFunction() {
    console.log('I see ' + outerValue);
    console.log('I see ' + innerValue);
  }

  later = innerFunction;
}

outerFunction();
later(); // I see ninja. I see samurai.
```

В МОМЕНТ ОБЪЯВЛЕНИЯ внутренней функции было образовано замыкание, охватывающее

не только саму эту функцию, но и все переменные в ее области видимости на момент

объявления функции. Даже когда мы фактически вышли из функции во внешнюю переменную

`later`, действует "оболочка" для функции и ее переменных на момент объявления функции.

Оболчка живет пока существует функция.

- ## `Закрытые переменные`

Иногда надо спрятать переменную от доступа.

```
function Ninja() {
  let feints = 0;
  this.getFeints = function () {
    return feints;
  };
  this.feint = function () {
    feints++;
  };
}

const ninja1 = new Ninja();
const ninja2 = new Ninja();

ninja1.feint();
ninja2.feint();
ninja2.feint();
ninja1.getFeints(); // 1
ninja1.getFeints(); // 2
```

Благодаря `new` был создан новый экземпляр объекта со своим контекстом и областью видимости.

Переменная `feints` не доступна из-вне, она существует в замыкании экземплаяра объекта.

Сам экземпляр объекта доступен через переменную `ninja1/2`

- ## `Замыкания и callback`

```
// Блок ползет вниз по диагонали...
function animatadBox(elem) {
  const box = document.querySelector(elem);
  let tick = 0;
  let timer = setInterval(function () {
    if (tick < 100) {
      box.style.left = box.style.top = tick + 'px';
      tick++;
    } else {
      clearInterval(timer);
    }
  }, 10);
}
animatadBox('.tick-box');
```

Здесь колбек `setInterval` получает возможность работать с внутренними переменными,

которые не доступны из глобальной видимости.

Но если вынести счетчик `tick` из функции, то все тоже сработает.!!!

Но, если нам надо анимировать 2 или более элемента, то каждому понадобиться

отдельный внешний счетчик, а так - нет !!!

Важно!

## Замыкания позволяют получить доступ к переменным не только в момент их определения.

## Нам доступны данные даже в процессе их обновления!

## Замыкание - это не моментальный снимок состояния облаcти видимости в момент ее создания.

## Это активная инкапсуляция данного состояния с возможностью изменений, при условии существования замыкания.

- ## `Отслеживание кода с помощью контекстов`

Функция - основной исполняющий блок в `JS`.

В `JS` есть

- глобальный контекст выполнения

и

- контекст выполнения функции

`Контекст функции` - объект, для которого она вызывается. Он доступен через `this`.

`Контекст выполнения функции` - ход выполнения функции, за ним следит интерперетатор кода.

Каждый вызов функции предполагает прерывание текущего контекста и созлание нового.

Старый контекст обычно удаляется.

- `стек вызовов`

За всем этим следит `стек вызовов` - то есть `стек контекстов выполнения`.

`Стек` - основополагающая структура данных, где положить что-то можно только на вершину

стопки и взять тоже только с вершины. (как подносы в столовой)

Как это работает с функциями?

```
function sayName(name) {
  report(name);
}
function report(value) {
  console.log(value);
}
sayName('Bob');
sayName('Louis-Ferdinand');

```

- `стек контекстов выполнения (стек вызовов)`

1. Есть глобальный контекст (он создается один раз для программы / веб-страницы).

   (Помним, что в `JS` одновременно может выполнятся только один фрагмент кода!)

   В глобальном контексте изначально глобально определяются две функции `sayName()` и `report()`.

2. Глобальный контекст прерывается и затем вызывается и выполняется `sayName()` с аргументом `'Bob'`,

   для этого создается `новый` контекст выполнения и размещается на вершине стека!

3. Так как `sayName()` в свою очередь вызывает `report(), то контекст выполнения `sayName()` прерывается

   и создается новый для `report().

4. Как только `report()` отработала код, ее контекст удаляется из стека и

   возобновляется контекст `sayName()`.

5. Как только отработал код `sayName()`, он удаляется из стека и возобновляется глобальный контекст.

   и так далее.

```
                              report()
                sayName()     sayName()     sayName()
глобальный ||  глобальный || глобальный || глобальный ||  глобальный ||
```

- ## `Лексическая среда ( область видимости )`

`Лексическая среда` - внутренняя структура интерпретатора `JS`.

Она сопостовляет корректность идентификаторов и имен пременных.

Ее часто называют `областью видимости`.

Она может быть связана с функцией, блоком кода, частью оператора.

До `ES6` область видимости была связана только с функциями.

- `вложенность`

Лексическая среда часто связана с вложенностью кода.

```
function fn() {

  function fn2() {
    for(...)
  }
  fn2();
}

```

Функции и циклы вложены в друг друга и имеют лексические среды.

Внутренние структуры имеют доступ к переменным из внешних блоков кода.

Если идентификатор (переменная) не найден в текущей среде, идет поиск во внешних...

Остановится , если найден, если есть ссылочная ошибка, если достигли глобального контекста и ничего нет.

- Всякий раз, когда создается функция, он хранит ссылку на лексическую среду, в которой была создана!

Это внутреннее закрытое свойство `[[Environment]]`

Вызвали функцию `=>` есть контекст выполнения в стеке `=>` есть область видимости `=>` через

`[[Environment]]` получаем ссылку на внешнюю среду - то есть контекст в котором ее создали.
