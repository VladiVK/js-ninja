## Functions

### `1.1- Функции - Сохранение уникальных функций в коллекции`

---

Будут вводиться в кэш только уникальные функции. Проверка по наличию ID.

Функция - объект высшего порядка и ничто не мешает добавить свойство

в функцию: `fn.id = 2;`

```
const store = {
    nextID: 1,
    cache: {},
    add: function (fn) {
        if (!fn.id) {
        fn.id = this.nextID++;
        this.cache[fn.id] = fn;
        return true;
        }
    },
};

function fnOne() {}
function fnTwo() {}
function fnThree() {}

store.add(fnOne);
store.add(fnTwo);
store.add(fnThree);

```

### `1.2- Функции - Запоминание (memoization) ранее вычисленных значений`

---

Запоминание `(memoization)` представляет собой построение функции, способной запомнить

ранее вычисленные значения. Позволяет избегнуть дорогостоящих повторных вычислений.

`Алгоритм вычисления простых чисел (больше 1 и делется без остатка только на 1 и само себя)`

```
function isPrime(value) {
  // create cache

  if (!isPrime.answers) {
    isPrime.answers = {};
  }

  // check if we have cached notes

  if (isPrime.answers[value] !== undefined) {
    return isPrime.answers[value];
  }

  // calculation

  let prime = (value !== 0 && value !== 1);

  for (let i = 2; i < value; i++) {
    if (value % i === 0) {
      prime = false;
      break;
    }
  }

  // save computed value
  isPrime.answers[value] = prime;

  //   return result
  return isPrime.answers[value];
}

isPrime(3);
isPrime(4);
isPrime(5);

console.log(isPrime.answers);


```

### `1.3 - Функции -Определение функций`

---

1. Объявление функции и функционального выражения

`function fn(){ return 'hello' }`

2. Стрелочные (часто наз. лямбда-функции)

`(arg) => return arg;`

3. Конструкторы функций ( не путать с функциями-конструкторами !!! )

`new Function('a', 'b', 'return a + b')`

4. Функции-генераторы

`function* myGen() {yield 1}`

Если мы объявляем функцию через `function`, то имя обязательно:

к ней ведь надо как-то обращаться потом!!!

Но, если через функциональное выражение, то не обязательно:

`const fn = function() {}`

### `1.4 - Функции - IIFE - Немедленно вызываемые функциональные выражения`

---

Это позволяет изолировать код ( эпоха до модулей )

```
(function (arg) {
  console.log('arg: ', arg);
}(3));

(function (arg) {
  console.log('arg: ', arg);
})(3);

(funtion(){}())

(funtion(){})()

+function(){}();

-function(){}();

~function(){}();

!(function () {})();


let person1 = (() => 'Bob')(); // 'Bob'

let person2 = (() => {'Bob'})(); // undefined

```

### `1.5 - Функции - Параметры и аргументы`

---

Если в функции предполагается параметров больше, чем по факту передали аргументов при вызове,

то им присваивается `undefined`;

Если аргументов, больше, чем параметров, то лишние аргументы просто никому не присваиваются!

`Оперетор ...rest`

Речь идет именно об "оставшемся параметре" - последнем!!!

Наличие его в середине параметров недопустимо!

Используем при определениии / объявлении функциии !

Спред же используем если надо при вызове с аргументами уже ...!!!

`...rest` выступит в качестве массива оставшихся аргументов!!!

Задача: умножить первый аргумент на наибольший из оставшихся:

```
function multiplyMax(first, ...rest) {
  const sorted = rest.sort((a, b) => b - a);
  return first * sorted[0];
}

multiplyMax(3, 1, 2, 3);
// 3 * 3 = 9;

вызов со спредом:

multiplyMax(3, 1, 2, 3, ...[1, 2, 5]);

// 3 * 5 = 15


```

`Параметры по умолчанию`

Старый подход:

```

function fn(par1, par2) {
  par2 = typeof par2 === 'undefined' ? 'Bob' : par2;
  return `${par1} ${par2}`;
}

```

Новый подход:

```

function fn(par1, par2 = 'Bob') {
  return `${par1} ${par2}`;
}

```

Можно даже так (но это bad practice):

```

function fn(par1, par2 = 'Bob', par3 = `${par1} ${par2}`) {
  return par3;
}

```

### `1.6 - Функции - Параметры this и arguments`

---

Это неявные параметры, они дефолтно передаются функциям.

`this` - контекст функции, объект для которого она вызывается.

`arguments` - все аргументы, передаваемые при вызове функции.

## `arguments`

передаются неявно, но по умолчанию и находятся в области видимости функции

Это коллекция всех аргументов. После ES6 оператора `...rest` потребность

в `arguments` существенно сократилась.

Коллекция `arguments` похоже на массив! Но это НЕ МАССИВ!

Есть свойство `arguments`, можно обращаться к элементам по индексу, но это не массив.

Методы массива работать не будут!

```
function sum() {
  let sum = 0;

  for (let i = 0; i < arguments.length; i++) {
    sum += arguments[i];
  }

  return sum;
}


sum(1,2,3); // 6

```

Но проще использовать `...rest` так как это уже подлинный массив!

```
function sum(...rest) {
  return rest.reduce((acc, val) => acc + val, 0);
}

sum(1,2,3); // 6
```

Коллекция `arguments` позволяет задавать псевдонимы параметрам, но это изменит и

значение аргументов:

```
function demo(person) {
  arguments[0] = 'ninja';

  return `the person is ${person}`;
}

demo('Rembo'); // 'ninja' не 'Rembo'

```

Это все считается как баг...

Поэтому используетс `'use strict'`, который не позволяет менять значение аргументов.

То есть параметру можно задать псевдоним, но аргумен не изменится.

## `this`

Это неявный параметр. Означает объект, связанный с вызовом функции - то есть контекст функции!!!

Ошибочно считать, что `this` указывает на экземпляр объекта, в котором определен метод.

`this` определяется не тем, как функции объявляется, а тем, как она вызвана!!!!

### `1.7 - Функции - Вызов функции`

---

В `JS` способ вызова функции влияет на порядок выполнения кода и

установку параметра `this`

Есть 4 способа вызова функции со своими особенностями.

1. как функция `demo()`

2. как метод `ninja.demo()`

3. как конструктор `new Ninja()`

4. через методы `apply` и `call` отдельной функции `demo.call(ninja)`

- ## Вызов как функции

Это вызов с помощью опреатора скобок `()`, и выражение на которое операция вызова ссылается

не является методом объекта!

```
demo();

const demo = function(){};
demo();

(function(){})()

```

При таком вызове устанавливается контекст `this` двояко:

при обычном режиме - это `window`

при строгом - это `undefined`

```
function demo() {
  this.id = '1nvfuvh75';
  return this.id;
}

demo(); // '1nvfuvh75';


window.id; // '1nvfuvh75';
```

Все зависит от очереди вызова функции еще:

```
function demo() {
  this.id = '01-demo';
  return this.id;
}
function test() {
  this.id = '01-test';
  return this.id;
}

До вызова функций window.id; // undefined

demo();
window.id; // 01-demo;

test();
window.id; // 01-dtest;
```

Вызов функции переписал глобальный контекст в нашем случае.

- ## Вызов как метод

```
const ninja = {};
ninja.skulk = function () {
  return this;
};
ninja.skulk();

```

Это означает, что при таком вызове функции ее контекстом становится объект!!!

И через `this` нам этот контекст / объект доступен.

```
ninja.skulk() === ninja; // true
```

Ниже видно, что контекст будет менятся в зависимости от того, как вызвана функция `outer()`:

```
function myContext() {
  return this;
}

myContext(); // window

const ninja = {
  getInfo: myContext;
}

ninja.getInfo(); // ninja;

ninja.getInfo() === ninja; // true

```

Поэтому не обязательно создавать новые одинаковые функции для разных объектов.

- ## Вызов через конструктор

Вызов через конструктор предполагает использования

ключевого слова `new`.

Конструкторы функций не стоит путать с функциями-конструкторами, которые нужны для инициализации

и создания экземпляров объектов !!!

```
function Ninja() {
  this.skulk = function () {
    return this;
  };
}

const ninja1 = new Ninja();
const ninja2 = new Ninja();

ninja1.skulk() === ninja1; // true
ninja2.skulk() === ninja2; // true

```

1. Есть конструктор, который создает экземпляр пустого объекта,

2. и этот пустой объект будет контекстом функции через `this`

3. метод `skulk` вернет `this` вновь созданного объекта

У функций конструкторов есть особенности !!!!

### Изменим код и вернем из конструктора простое строчное значение.

```
function Ninja() {
  this.skulk = function () {
    return this;
  };
  return 'I am Ninja constructor!';
}

Ninja(); // I am Ninja constructor!

```

При этом все остальное также работает:

```
const ninja1 = new Ninja();
const ninja2 = new Ninja();

ninja1.skulk() === ninja1; // true
ninja2.skulk() === ninja2; // true

```

Но перепишем код:

```
const sumuray = {
  name: false,
};

function Ninja() {
  this.skulk = true;
  return sumuray;
}

const ninja1 = new Ninja();
const ninja2 = new Ninja();

ninja1.skulk; // undfined
ninja2.skulk; // undfined

ninja1.name; // false
ninja2.name; // false



```

Итак, усли конструктор возвращает простое значение (НЕ ОБЪЕКТ), то

все работает и контекст `this` создается.

НО если возвращается ОБЪЕКТ, то результатом всей операции через `new`

будет просто возврат этого самого объекта. А вновь созданный объект с параметром

`this` просто игнорируется.

То есть `ninja1` станет просто второй ссылкой на внешний объект `sumuray`

```
ninja1 === sumuray; // true
```

Функции-конструкторы обычно кодируются иначе, чем обычные функции. В другом случае от них

мало пользы.

Пример проблемы: вызовем конструктор как простую функцию без `new`

```
function Ninja() {
  this.skulk = function () {
    return this;
  };
}

const ninja1 = Ninja();

```

Мы просто создали метод `skulk` для глобального объекта `window`,

а в `ninja1` у нас будет `undefined`.

Поэтому для именования консрукторов берутся обычно существительные `Car()` `Ninja()`

и пишутся с большой буквы.

Обычные функции именуются глаголами.

- ## Вызов через `apply` методы и `call`

Итак, в зависимости от того, как вызвана функция, будет установлен ее контекстный объект с

указателем `this` на этот контект.

- вызовем просто как функцию верхнего уровня и получим контекст `window`

- вызовем как метод объекта и получим контекст в виде объекта-владельца метода

- вызовем через конструктор и получим контекст в виде экземпляра нового объекта

Представим ситуацию-проблему:

```
function Button() {
  this.clicked = false;
  this.click = function () {
    this.clicked = true;
    console.log(this);
  };
}
const button = new Button();

const elem = document.querySelector('.btn');

elem.addEventListener('click', button.click);


```

Мы нажимаем на кнопку и метод объекта `button` сработает, но

не для него, а для `elem` - то есть кнопки;

```
console.log(this); // <button class='btn>
то есть elem наш !!!

elem.clicked; // true стал
```

Контекстом для `this` выступил объект, к которомы привязан обработчик событий.

- ## Применение `apply` и `call`

В JS можно можно вызвать функцию и ЯВНО УКАЗАТЬ ОБЪЕКТ для КОНТЕКСТА этой функции.

У каждой функции (как объекта) есть методы `apply()` и `call()`

`apply` - вызываем и передаем два параметра: объект для контекста и `массив` аргументов

`call` - - вызываем и передаем два параметра: объект для контекста и `список` аргументов

Решим проблему предыдущую (здесь метод и аргументы вторичны):

```
elem.addEventListener('click', function () {
  button.click.apply(button);
});
```

или

```
elem.addEventListener('click', function () {
  button.click.call(button);
});

```

Привидем иной пример. Используем всю функцию для вычисления, а не просто метод.

```
function juggle() {
  let result = 0;

  for (let i = 0; i < arguments.length; i++) {
    result += arguments[i];
  }

  this.sum = result;
}

const ninja1 = {};
const ninja2 = {};

juggle.apply(ninja1, [2, 3, 4, 5]);
juggle.apply(ninja2, 1,2,3,4);

```

- ## Контекст и стрелочные функции `() => {}`

У стрелочных функций отсутствует собственный контекст !!!

Вместо этого они наследуют контекст той функции, в которой определяются.

То есть во время вызова они не получают свой неявный параметр `this`.

Но они помнят контекст для `this` в момент своего создания.

Перепишем пример с кнопкой:

```
function Button() {
  this.clicked = false;
  this.click = () => {    // замена на стрелочную
    this.clicked = true;
    console.log(this);
  };
}

```

далее

```
const button = new Button(); // момент создания !!! Контекст будут запомнен

```

далее

```
const elem = document.querySelector('.btn');

elem.addEventListener('click', button.click);

```

теперь

```
button.clicked; // true
```

- ## Ловушка глобального `window` и стрелочные функции `() => {}`

Немного перепишем код:

```
const button = {
  clicked: false,
  click: () => {
    this.clicked = true;
    console.log(this);
  },
};

const elem = document.querySelector('.btn');

elem.addEventListener('click', button.click);

// this выступит для глобального объекта `window` !!!

window.clicked; // true
button.clicked; // false
```

В глобальном коде стрелочная фнкция ссылается на глобальный объект `window`.

Правило: если стрелочная функция определяется в обычно литеральном объекте,

который, в свою очередь написан просто на верхнем уровне, в глобальном коде,

то значением `this` для стрелочной функции станет `window`

- ## Вызов через метод `bind()`

Каждой функции доступен метод `bind()`.

Он служит для создания новой функции. Эта функции имеет то же самое тело, но

ее контекст всегда привязан к определенному объекту, независимо от

способа вызова !!!

Для начала избавимся от стрелочной функции в литерале объекта

```
const button = {
  clicked: false,
  click: function () {    // нет стрелки больше
    this.clicked = true;
    console.log(this);
  },
};
```

```
const elem = document.querySelector('.btn');

elem.addEventListener('click', button.click.bind(button));
```

Метод `call()` требовал обертку, что сразу вызов не сработал

```
elem.addEventListener('click', function () {
  button.click.call(button);
});
```

Метод `bind()` используется для создания и возврата новой функции, привязанной

к передаваемому в этой функции объекту: `button.click.bind(button)`

`this` всегда укажет на контекст этого объекта.

Метод `bind()` не изменяет исходную функции - всегда создается и возвращается новая

### `1.8 - Функции - Замыкания`

---

Замыкания - определяющее языковое средство `JavaScript`.

Введения замыканий и способа написания кода с ними определили перспективы языку.

- ## `Общее представление о замыканиях`

`Замыкание` предоставляет функции доступ к внешним по отношению к ней переменным и

возможность ими манипулировать. В момент определения функции формируется ее область видимости

и замыкание дает доступ ко всем переменным и функциям в этой области видимости.

`Область видимости` - доступность идентификаторов (видимость их) в определеннях

частях программы.

Простой пример замыкания: переменая и функции объявлены в одной (глобальной)

области видимости

```
let value = 'ninja;
function getNinja() {}
```

Еще пример:

Переменная `later` получила доступ к `innerValue` через замыкание.

```
let outerValue = 'ninja';
let later;

function outerFunction() {
  let innerValue = 'samurai';
  function innerFunction() {
    console.log('I see ' + outerValue);
    console.log('I see ' + innerValue);
  }

  later = innerFunction;
}

outerFunction();
later(); // I see ninja. I see samurai.
```

В МОМЕНТ ОБЪЯВЛЕНИЯ внутренней функции было образовано замыкание, охватывающее

не только саму эту функцию, но и все переменные в ее области видимости на момент

объявления функции. Даже когда мы фактически вышли из функции во внешнюю переменную

`later`, действует "оболочка" для функции и ее переменных на момент объявления функции.

Оболочка живет пока существует функция.

- ## `Закрытые переменные`

Иногда надо спрятать переменную от доступа.

```
function Ninja() {
  let feints = 0;
  this.getFeints = function () {
    return feints;
  };
  this.feint = function () {
    feints++;
  };
}

const ninja1 = new Ninja();
const ninja2 = new Ninja();

ninja1.feint();
ninja2.feint();
ninja2.feint();
ninja1.getFeints(); // 1
ninja2.getFeints(); // 2
```

Благодаря `new` был создан новый экземпляр объекта со своим контекстом и областью видимости.

Переменная `feints` не доступна из-вне, она существует в замыкании экземпляра объекта.

Сам экземпляр объекта доступен через переменную `ninja1/2`

- ## `Замыкания и callback`

```
// Блок ползет вниз по диагонали...
function animatadBox(elem) {
  const box = document.querySelector(elem);
  let tick = 0;
  let timer = setInterval(function () {
    if (tick < 100) {
      box.style.left = box.style.top = tick + 'px';
      tick++;
    } else {
      clearInterval(timer);
    }
  }, 10);
}
animatadBox('.tick-box');
```

Здесь колбек `setInterval` получает возможность работать с внутренними переменными,

которые не доступны из глобальной видимости.

Но если вынести счетчик `tick` из функции, то все тоже сработает.!!!

Но, если нам надо анимировать 2 или более элемента, то каждому понадобиться

отдельный внешний счетчик, а так - нет !!!

Важно!

## Замыкания позволяют получить доступ к переменным не только в момент их определения.

## Нам доступны данные даже в процессе их обновления!

## Замыкание - это не моментальный снимок состояния облаcти видимости в момент ее создания.

## Это активная инкапсуляция данного состояния с возможностью изменений, при условии существования замыкания.

- ## `Отслеживание кода с помощью контекстов`

Функция - основной исполняющий блок в `JS`.

В `JS` есть

- глобальный контекст выполнения

и

- контекст выполнения функции

`Контекст функции` - объект, для которого она вызывается. Он доступен через `this`.

`Контекст выполнения функции` - ход выполнения функции, за ним следит интерперетатор кода.

Каждый вызов функции предполагает прерывание текущего контекста и созлание нового.

Старый контекст обычно удаляется.

- `стек вызовов`

За всем этим следит `стек вызовов` - то есть `стек контекстов выполнения`.

`Стек` - основополагающая структура данных, где положить что-то можно только на вершину

стопки и взять тоже только с вершины. (как подносы в столовой)

Как это работает с функциями?

```
function sayName(name) {
  report(name);
}
function report(value) {
  console.log(value);
}
sayName('Bob');
sayName('Louis-Ferdinand');

```

- `стек контекстов выполнения (стек вызовов)`

1. Есть глобальный контекст (он создается один раз для программы / веб-страницы).

   (Помним, что в `JS` одновременно может выполнятся только один фрагмент кода!)

   В глобальном контексте изначально глобально определяются две функции `sayName()` и `report()`.

2. Глобальный контекст прерывается и затем вызывается и выполняется `sayName()` с аргументом `'Bob'`,

   для этого создается `новый` контекст выполнения и размещается на вершине стека!

3. Так как `sayName()` в свою очередь вызывает `report()`, то контекст выполнения `sayName()` прерывается

   и создается новый для `report().

4. Как только `report()` отработала код, ее контекст удаляется из стека и

   возобновляется контекст `sayName()`.

5. Как только отработал код `sayName()`, он удаляется из стека и возобновляется глобальный контекст.

   и так далее.

```
                              report()
                sayName()     sayName()     sayName()
глобальный ||  глобальный || глобальный || глобальный ||  глобальный ||
```

- ## `Лексическая среда ( область видимости )`

`Лексическая среда` - внутренняя структура интерпретатора `JS`.

Она сопостовляет корректность идентификаторов и имен пременных.

Ее часто называют `областью видимости`.

Она может быть связана с функцией, блоком кода, частью оператора.

До `ES6` область видимости была связана только с функциями.

- `вложенность`

Лексическая среда часто связана с вложенностью кода.

```
function fn() {

  function fn2() {
    for(...)
  }
  fn2();
}

```

Функции и циклы вложены в друг друга и имеют лексические среды.

Внутренние структуры имеют доступ к переменным из внешних блоков кода.

Если идентификатор (переменная) не найден в текущей среде, идет поиск во внешних...

Остановится , если найден, если есть ссылочная ошибка, если достигли глобального контекста и ничего нет.

- Всякий раз, когда создается функция, он хранит ссылку на лексическую среду, в которой была создана!

Это внутреннее закрытое свойство `[[Environment]]`

Вызвали функцию `=>` есть контекст выполнения в стеке `=>` есть область видимости `=>` через

`[[Environment]]` получаем ссылку на внешнюю среду - то есть контекст в котором ее создали.

- ## `Переменные и область видимости`

Ключевые слова `var, let, const` характеризуются 2 моментами:

1. изменяемостью

2. взаимосвязью с лексической средой ( областью видимости );

Обычно `const` используют в двух разных случаях:

- когда значение не должно меняться или это массив / объект

- когда часто надо обращаться к фиксированному значению: `const MAX_LENGTH = 600;`

Значение для `const` можно задать только сразу с объявлением самой константы.

Особенность `var` в том, что переменная доступна в своей лексической среде и

`не ограничена блоками` кода. В др. языках такого не было и народ страдал...

То есть `var` определенная в цикле `for(var i = 0; ...)`, будет доступна вне

тела цикла( как только он отработает и дойдет очередь):

```
function calc() {

  for(var i = 0; i < 3; i++) {
    .....
  }

  return i; // 3
}
```

Именно поэтому было введено `let` и `const`:

они определяю переменные в `ближайшей` лексической среде (цикл, блок, функции, глобальная);

```
function calc() {

  for(let i = 0; i < 3; i++) {
    .....
  }

  return i; // ERROR: i is not defined
}
```

- ## `Регистрация идентификаторов в лексической среде`

Код `JS` выполняется построчно и непосредственно!

Но мы можем без проблем вызвать функцию до ее объявления в коде.

```
demo();
function demo() {...}

```

На самом деле интерпретатор `JS` работает в два этапа:

1. На этапе создания новой лексической среды, пока код еще не выполнен,

   интерпретатор `JS` просматривает и регистрирует все переменные и функции,

   объявленные в текущей лексической среде.

2. Выполение кода.

Работает это так:

- если создается глобальная среда или среда функции, то в текуще коде,

  не доходя до тела функций создается новая функция, привязанная к идентиикатору по

  своему имени. Функциональные выражения и стрелочные функции не в счет !!!

  Среда блоков игнорируется.

- текущий код проверяется на наличие объявления переменных. С присваиванием значений или `undefined`

  В блоках проверяется только наличие `let` и `const`.

Особености:

- функции, определенные через опреатор объявления функции ` function demo(){}`

  доступны к использованию до их объявления.

- функциональные выражения и стрелки заранее недоступны

- ## `Всплытие (hoisting)`

Это в целом жаргон. Работа с лексической средой все это объясняет.

Интерпретатор на первом этапе создает идентификаторы переменным и функциям.

Потом он с ними просто связывается.

`Всплытие` касается `function() и var`. Но `let` и `const` нельзя использовать

до объявления.

- ## `Еще раз: Принцип действия замыканий`

Замыкание - механизм, предоставляющий функции доступ ко всем переменным

из области видимости в момент создания самой функции.

Замыкания тесно и бесповоротно связаны с областью видимости.

Замыкания - побочный эффект областей видимости на основе правил их использования.

`"закрытые переменные"` - вопрос относительный.

Нам ничтно не мешает присвоить объекту свойство, созданное в другом объекте!

```
function Ninja() {
  let feints = 0;

  this.feint = function () {
    feints++;
  };
  this.getFeints = function () {
    return feints;
  };
}

const ninja1 = new Ninja();
ninja1.feint();

const imposter = {};
imposter.getFeints = ninja1.getFeints; // 1

```

Мы получили значение "закрытой переменной".

Если закрыть надо, то пропишем не через `let`, а через `this`

```
function Ninja() {
  this.feints = 0; !!!

  this.feint = function () {
    this.feints++;   !!!
  };
  this.getFeints = function () {
    return this.feints; !!!
  };
}

const ninja1 = new Ninja();
ninja1.feint();

const imposter = {};
imposter.getFeints = ninja1.getFeints; // undefined !!!!

```

`Для чего нужны замыкания?`

- для имитации закрытых объектных переменных

- для приминения колбэков

### `1.9 - Функции - Генераторы и Promise`

---

`Генератор` - функция особого типа. Обычные функции вычисляют и возвращают не больше одного значения

при выполнении от начала и до конца.

Генераторы могут вычислять и возвращать по несколько значений (одно! для каждого запроса),

приостанавливая свое выполнение между запросами.

`Promise` - новый встроенный тип объектов, помогающий работать с асинхронным кодом.

Это, `обязательство`, заполнитель значения, которого еще нет, но ожидается в будущем моменте.

В `JS` однопоточная модель выполнения кода. Пока операция не выполнится, изменения интерфейса блокируется.

Избегают этого с помощью `колбеков`, которые будут работать по принципу `if .. else`

```
getDataJSON( 'ninja.json', function(err, ninjas) {
  if(err) {
    //....
    return
  }
  getDataJSON(ninjas[0].names, function(err, mission) {
    ....
  })
})

```

Перепишем с помощью генератора и разберем в будущем:

```
async (function* () {
  try {
    const ninjas = yield getData('ninjas.json');
    const missions = yield getData(ninjas[0].missions);
    // ....

  } catch (error) {
    // handle error
  }
})

```

### `1.10 - Функции - Генераторы`

---

`Генератор` - функция, генерирующая последовательность значений, но не сразу, а по запросу.

Она либо возвращает значение, либо говорить, что генерировать больше нечего.

После генерирования конкретного значения, функция не завершает работу, а лишь приостанавливает

и при новом вызове начинает с места остановки.

```
function* NamesGenertor() {
  yield 'Bob';
  yield 'Homer';
  yield 'Louis-Ferdinand';
}

for (let name of NamesGenertor()) {
  console.log(name);
}

// Bob
// Homer
// Louis-Ferdinand
```

У функции-генератора нет оператора `return`. Ее вызов не приводит в возврату значения!!!

Вызов приводит к созданию объекта, называемого `итератором`.

У `итератора` есть метод `next()`, который вызывает выполнение кода в `генераторе`,

пока он не натолкнется на ключевое слово `yield`.

Получаем промежуточные результат (то есть один из сгенерируемых элементов) и возвращаем

`новый объект`, сообщающий завершена ли работа или можно дальше генерировать.

Свойство `done` будет `false` так как работа не завершена, а приостановлена без блокировки кода.

В конце концов, генератор вернет значение {`value: undefined}` и выполнено `{done: true}`

```
function* NamesGenertor() {
  yield 'Bob';
  yield 'Homer';
  yield 'Louis-Ferdinand';
}

const namesIterator = NamesGenertor();

let item = namesIterator.next();

console.log(item);
// {value: "Bob", done: false}
```

```
function* NamesGenertor() {
  yield 'Bob';
  yield 'Homer';
  yield 'Louis-Ferdinand';
}

const namesIterator = NamesGenertor();
let item;

while (!(item = namesIterator.next()).done) { // item.done !== true;
  console.log(item);
}

// {value: "Bob", done: false}
// {value: "Homer", done: false}
// {value: "Louis-Ferdinand", done: false}
```

Вот таким образом и работает метод перебора массива `for-of`.

У него есть `итератор`, который и вызывает `next()` автоматически

- ### `Поручение выполнения другому генератору`

Все пройдет как в обычном порядке. Методу `next()` все равно, что он перепоручен.

```
function* NamesGenertor() {
  yield 'Bob';
  yield 'Homer';
  yield* frenchGenerator();
  yield 'Sokrat';
}
function* frenchGenerator() {
  yield 'Louis-Ferdinand';
  yield 'Jean-Paul Sartre';
}

for (let name of NamesGenertor()) {
  console.log(name);
}
// Bob
// Homer
// Louis-Ferdinand
// Jan-Paul Sartre
// Sokrat
```

- ## `Использование генератора`

- `Создамим генератор уникальных идентификаторов` без глобальной переменной:

Здесь бесконечный цикл безопасен, так как до последующего вызова

метода `next()` выполнение работы генератора приостанавливается

```
function* IdGenerator() {
  let id = 0;
  while (true) {
    //бесконечный цикл генерации id по вызову !!!
    yield ++id;
  }
}

const idIterator = IdGenerator();  // создадим объект-итератор

const ninja1 = {
  id: idIterator.next().value,  // 1
};
const ninja2 = {
  id: idIterator.next().value,  // 2
};
const ninja3 = {
  id: idIterator.next().value,  // 3
};
```

- `Обход модели DOM`

1. Обычный подход

Создадим рекурсивную функцию, бходящую модель `DOM` в рамках указанного идентификатора:

```
function traverseDOM(element, callback) {
  callback(element);
  element = element.firstElementChild;
  while (element) {
    traverseDOM(element, callback);
    element = element.nextElementSibling;
  }
}

const subTree = document.querySelector('.section-center');
traverseDOM(subTree, (elem) =>
  console.log(
    `Element ${elem.nodeName} has classList: ${
      elem.classList.length > 0 ? elem.classList : 'Ups, no classes'
    }`
  )
);
```

2. Итератор, позволяющий избежать колбеков

```
function* DomTraversal(element) {
  yield element;
  element = element.firstElementChild;
  while (element) {
    yield* DomTraversal(element);
    element = element.nextElementSibling;
  }
}

const subTree = document.querySelector('.section-center');

for (let elem of DomTraversal(subTree)) {
  console.log(elem.nodeName);

  if (elem.classList.contains('demo'))
    console.log(`${elem.nodeName}: ${elem.textContent}`);
}
```

### `1.11 - Функции - Promise`

---

Понятие `Promise` было введено, чтобы упростить решение асинхронных задач.

`Promise` - заполнитель значения, которое отсутствует в настоящий момент, но появится потом.

`Promise` гарантирует, что результат асинхронного вычисления в конечном итоге станет известным.

Выполнен промис и получили значение, иначе получено извинение в виде ошибки!

```
const person = new Promise((resolve, reject) => {
  resolve('Louis-Ferdinand');
  // reject('Ups, Error!');
});
```

Вызываем метод `then()` и передаем ему два колбека
первый вызовется, если промис выполнен
То есть у нас в аргумент первого колбека попадает то, что вернул` resolve()`

```
person.then(
  (name) => {
    if (name === 'Louis-Ferdinand') {
      console.log('We promised Louis-Ferdinand');
    }
  },
  (err) => console.log(err)
);

// We promised Louis-Ferdinand
```

1. Для создания промиса используем операцию `new` и встроенный конструктор объектов типа `Promise`.

2. Конструктору передается функция-исполнитель с двумя параметрами: `resolve` & `reject`.

3. Исполнитель вызывается `немендленно` при конструировании объекта и ему в качестве аргументов

   передаются два колбека: `resolve` & `reject`.

4. `resolve` вызывается вручную, если требуется выполнить обещание

   `reject` - для ошибки.

Асинхронный код нужен, чтобы исключить блокирование работы приложения.

Пользователь не должен ждать... Раньше это решалось с помощью обратных вызовов. Целой цепи

обратных вызовов. Писались библиотеки и разнились подходы...

Поэтому появился `Promise`....

Сразу после создания `Promise` находится в состоянии "ожидания разрешения".

Если в ходе выполнения кода вызывается функция `resolve()`, то он переходит

в состояние "разрешено". Если `reject()`, то в "отклонено". Обещеное значение получить

нельзя, но хоть известна причина.

```
const marker = false;

const person = new Promise((resolve, reject) => {
  if (marker) {
    resolve('Louis-Ferdinand');
  } else {
    reject('Ups, Error!');
  }
});
```

Теперь мы передаем в `then()` два колбека.

Один для успеха, второй - для отклонения и ошибки.

```
person.then(
  (name) => console.log(name),
  (err) => console.log(err),
)
```

Но красивее использовать метод `catch()`

```
person
  .then((name) => console.log('We promised ' + name))
  .catch((err) => console.log(err));
```

Методы равнозначны для использования, но метод `catch()` нагляднее демонстрирует цепочку.

До сих пор мы явно (вручную) генерировали ошибку.

Но она может обрабатываться и неявно.

```
const person = new Promise((resolve, reject) => {
counter++;
});

person
  .then((name) => console.log('We promised ' + name))
  .catch((err) => console.log(err));

  // ReferenceError: counter is not defined
```

Мы снова словили в промисе ошибку, когда пытались инкрементировать необявленную

переменную `counter`. Здесь возникло исключение и мы его словили без вызова `reject()`

### `Запрос для сервера`

Это основное использование промисов.

Привидем пример в старом синтаксисе:

```
function getJSON(url) {
  return new Promise((resolve, reject) => {
    const request = new XMLHttpRequest();
    request.open('GET', url); // инициализировать запрос

    // зарегистрируем обработчик событий
    request.onload = function () {
      try {
        if (this.status === 200) {
          // сервер ответил с нужным статусом
          resolve(JSON.parse(this.response));
        } else {
          // проблемы с сервером
          reject(this.status + ' ' + this.statusText);
        }
      } catch (error) {
        // синтаксические ошибки, другое состояние ответа
        reject(error.message);
      }
    };
    // при обмене с сервером ошибки пошли
    request.onerror = function () {
      reject(this.status + ' ' + this.statusText);
    };

    // отправить запрос серверу
    request.send();
  });
}

const url =
  'https://www.thecocktaildb.com/api/json/v1/1/search.php?s=margarita';

getJSON(url)
  .then((response) => console.log(response))
  .catch((err) => console.log('Some problem: ' + err));
```

### `Цепочка промисов`

Дело в том, что в результате вызова `then()` мы также получем новый промис.

И к нему можно применять свой `then()`

```
getJSON(url)
  .then( response => response.drinks)
  .then( drinks => console.log(drinks) )
  .catch( err => console.log('Some problem: ' + err));
```

При этом перехват ошибок методом `catch()` произойдет на любом этапе!!!

Метод `Promise.all()`

В данном случае методу передается массив промисов и он создает новый промис, который

выполняется только в том случае, если все промисы выполнены и отклоянется, если хотя бы

один из промисов отклонен.

```
Promise.all([
  getJSON(`https://www.thecocktaildb.com/api/json/v1/1/search.php?s=margarita`),
  getJSON(`https://www.thecocktaildb.com/api/json/v1/1/search.php?i=vodka`),
  getJSON(`https://www.thecocktaildb.com/api/json/v1/1/lookup.php?i=11007`),
])
  .then((results) => {
    const result_1 = results[0];
    const result_2 = results[1];
    const result_3 = results[2];
  })
  .catch((err) => console.log(err));
```

Метод `Promise.race()`

Если нам надо дать задание первому, кто откликнется, кто быстре всех...,

то используем этот метод:

```
Promise.race([
  getJSON(`https://www.thecocktaildb.com/api/json/v1/1/search.php?s=margarita`),
  getJSON(`https://www.thecocktaildb.com/api/json/v1/1/search.php?i=vodka`),
  getJSON(`https://www.thecocktaildb.com/api/json/v1/1/lookup.php?i=11007`),
])
  .then((result) => console.log(result))
  .catch((err) => console.log(err));
```

При этом перехват ошибок методом `catch()` произойдет на любом этапе!!!
